import argparse as apimport reimport platformfrom math import sqrtimport numpy as np######## RUNNING THE CODE #####################################################   You can run this code from terminal by executing the following command#   python planpath.py <INPUT/input#.txt> <OUTPUT/output#.txt> <flag>#   for example: python planpath.py INPUT/input2.txt OUTPUT/output2.txt 0#   NOTE: THIS IS JUST ONE EXAMPLE INPUT DATA################################################################################################# YOUR CODE GOES HERE ########################################def graphsearch(map, flag):    dim = int(map[0])     #saving dimension in dim     #am empty list tto store the matrix    l = []    map = map[1:]    # converting map to 2-d array    for i in map:        l.append([j for j in i])    l = np.array(l)        # chcek the start and the goal position    for i in range(dim):        for j in range(dim):            if l[i][j]=='S':                pointer = (i,j)        #save position of start into pointer                a=i                b=j            if l[i][j]=='G':                g1=i                g2=j        # functtion to return the move between current and next position    def action(start,end):                #if mover in same row         if start[0]==end[0]:            if start[1]<end[1]:                act = 'R'            else:                act = 'L'        #if move in next row        elif start[0]<end[0]:            if start[1]<end[1]:                act = 'RD'            elif start[1]==end[1]:                act = 'D'            else:                act = 'LD'        #if move in previous row        else:            if start[1]<end[1]:                act = 'RU'            elif start[1]==end[1]:                act = 'U'            else:                act = 'LU'        return act        # put current (start) position in visited, i.e closed list    visited=[(a,b)]        #initializing variables to be used further    output = ''         #an empty string to store the output    op = []    node=0    path = 0    hur = 0    minimum =0    direction = 'S'    S={}    N ={}    F={}    G={}    H={}    O={}    x=0        #creating dcicttionaries with some initial values    for i in range(dim):        for j in range(dim):            F[i,j]=0            #to store recent f-fun value of each position after every action if position is not open already            G[i,j]=0            #to store recent g-fun value of each position after every action if position is not open already            H[i,j]=0            #to store recent h-fun value of each position after every action if position is not open already            N[(i,j)] = 'N'+str(x)+':'                 #to store node number            S[(i,j)] = ''                             #to store every action of each node            O[(i,j)] = ''                             #to store every action of each node in open list            x+=1    S[pointer]='S'              #inittial position of start position    O[pointer]='S'              #initial position of sttart position    ############################################        if (flag==0):        # while we dontt reach the goal position        while a!=g1 or b!=g2:            node=node+1         # count of the number of iterations            start = pointer     #set start position of algorith to pointer (current node)            m=l                 # sample input of dim x dim            m = np.array(m)                        # if its not the start node 'S' put * for current position            if node != 1:                       m[a][b] = '*'            #for every row in sample input            for i in range(dim):                #each node of that row                for j in range(dim):                    #save to output                    output = output + m[i][j]                #add new line character after every row                output= output + '\n'            # add direction (movement till now) and g-fun value            output = output + str(direction) + ' ' + str(path)+ '\n\n'                        s =[]                #list to store positions of mountain around current pointer            moves =[]            #store positions of all 8 arounf the current pointer            # iteration from prebious row to next row            for x in range (-1,2):                #iteration from previous column to next column                for y in range(-1,2):                    #check if the pointer is at the edges                    if a+x in range(0,dim) and b+y in range(0,dim):                        #save each position around it                        moves.append((a+x,y+b))                        #also check if any of them is mountain and store its position in s                        if l[a+x][b+y]=='X':                            s.append((a+x,b+y))                        #list to store wrong move which are not availabe due to mountains             wrong_move = []            #for every position of mountain around            for (x,y) in s:                #if in the same row (adjacent) as pointer                if x==a:                    #for previous row and next row                    for m in range(-1,2):                        #check for edge                        if x+m in range(0,dim):                            #cant move in adjacent rows of that column                            wrong_move.append((x+m,y))                #if in the same column (adjacent) as pointer                elif y==b:                    #for previous column and next column                    for m in range(-1,2):                        #check for edge                        if y+m in range(0,dim):                            #cant move in adjacent rows of that column                            wrong_move.append((x,y+m))                #its diagonally located                else:                    #cant move to that position                    wrong_move.append((x,y))            #list of unique positions            wrong_move=list(set(wrong_move))            # possible moves = all 8 moves - no wrong moves due to mountain - already closed (visited) positions            pos_moves=[item for item in moves if item not in visited and item not in wrong_move]            #cost,g_fun,h_fun dictionaries to store current value of f,g,h fun resp. for all possible movements            cost = {}            g_fun = {}            h_fun = {}            #for every possible move            for (x,y) in pos_moves:                #if adjacent                if x==a or y==b:                    g=2+path                #if diagonal                else:                    g=1+path                #hueristic function = eucledean distance                 h=round(sqrt((x-g1)**2 + (y-g2)**2),2)                #append value to respective lists                g_fun[(x,y)] = g                h_fun[(x,y)] = h                cost[(x,y)] = g+h####################### tie breaking if total cost f = g+h is same #######################            #all positions with minimun total cost            keys = [k for k, v in cost.items() if v==min(cost.values())]            #if only one            if len(keys)==1:                #update pointer to that position, move to that position                pointer = keys[0]            #if more than one position has same minimun total value            else:                #dictionary of positions with min total value and there h value                h_min = [(k,v) for k,v in h_fun.items() if k in keys]                h_min = dict(h_min)                #total positions with min f and h value                h_val = [k for k,v in h_min.items() if v == min(h_min.values())]                #if one position has min f and h value                if len(h_val)==1:                    #update pointer                    pointer = h_val[0]                #else if one position has min f and g value                elif len(g_val)==1:                    #update pointer                    pointer = g_val[0]                #all values are same for these positions till now, so we will choose the most right or down position                else:                    #list of positions row and column as x and y                    x = [k[0] for k in keys]                    y = [k[1] for k in keys]                    #if only one position is at most down row                    if x.count(max(x)) == 1:                        #update pointer to move down                        pointer = [x for x in keys if x[0]==max(x)]                    else:                        #else update pointer to move to most right column                        pointer = [x for x in keys if x[1]==max(y)]                                    #update position to closed as it is visited            visited.append(pointer)            #update g cost till now            path = g_fun[pointer]            #update current position            a= pointer[0]            b= pointer[1]            #update direction with action from previous position to new pointer            direction =  direction + '-'+action(start,pointer)            #if reached goal state            if a==g1 and b==g2:                #update action with 'G' to show goal reached                direction=direction+'-'+'G'        #update output with last round and direction        for i in range(dim):            for j in range(dim):                output = output + l[i][j]            output= output + '\n'        output = output + str(direction) + ' '+ str(path)        return (output)  ######################################           elif(flag >= 1):        #for iterations = flag, while iterations less than or equal to flag        while node<flag:                        #some strings with some initial value for childres, open and closed list            children = 'Children: {'            OPEN = 'OPEN: {'            closed = 'CLOSED: {'            node=node+1                  # count of the number of iterations            print('Node = ',node)         # number of iteration            start = pointer               #set start position of algorith to pointer (current node)            print(N[pointer]+S[pointer],node,path,hur,minimum)            m = l                             # sample input of dim x dim                        #if current state is goal state, finish            if m[a][b]=='G':                break                                    s =[]                                  #list to store positions of mountain around current pointer            moves =[]                              #store positions of all 8 arounf the current pointer            # iteration from prebious row to next row            for x in range (-1,2):                #iteration from previous column to next column                for y in range(-1,2):                    #check if the pointer is at the edges                    if a+x in range(0,dim) and b+y in range(0,dim):                        #save each position around it                        moves.append((a+x,y+b))                        #also check if any of them is mountain and store its position in s                        if l[a+x][b+y]=='X':                            s.append((a+x,b+y))            #list to store wrong move which are not availabe due to mountains             wrong_move = []            #for every position of mountain around            for (x,y) in s:                #if in the same row (adjacent) as pointer                if x==a:                    #for previous row and next row                    for m in range(-1,2):                        #check for edge                        if x+m in range(0,dim):                            #cant move in adjacent rows of that column                            wrong_move.append((x+m,y))                #if in the same column (adjacent) as pointer                elif y==b:                    #for previous column and next column                    for m in range(-1,2):                        #check for edge                        if y+m in range(0,dim):                            #cant move in adjacent rows of that column                            wrong_move.append((x,y+m))                #its diagonally located                else:                    #cant move to that position                    wrong_move.append((x,y))                                ##list of unique positions            wrong_move=list(set(wrong_move))            # possible moves = all 8 moves - no wrong moves due to mountain - already closed (visited) positions            pos_moves=[item for item in moves if item not in visited and item not in wrong_move]            # all possible moves are open nodes                        #for ever node in possible moves            for end in pos_moves:                #if already not in open                if end not in op:                    #update node action in S identifier and Open list                    S[end] = S[pointer]+'-'+action(start,end)                    O[end] = O[pointer]+'-'+action(start,end)                else:                    #if already open, onlu update S, if already open we will use first identifier created for this node                    S[end] = S[pointer]+'-'+action(start,end)                #print all children (posible moves) from current node (pointer)                children = children+N[end]+ S[end]+','            print(children[:-1]+'}')             #cost,g_fun,h_fun dictionaries to store current value of f,g,h fun resp. for all possible movements            cost = {}            g_fun = {}            h_fun = {}            #for every possible move            for (x,y) in pos_moves:                #if adjacent                if x==a or y==b:                    g=2+path                #if diagonal                else:                    g=1+path                #hueristic function = eucledean distance                 h=round(sqrt((x-g1)**2 + (y-g2)**2),2)                #append value to respective dictionary                g_fun[(x,y)] = g                h_fun[(x,y)] = h                cost[(x,y)] = g+h                #if node already not open, update f,g,h value to final dictionary                if (x,y) not in op:                    F[x,y]=g+h                    G[x,y]=g                    H[x,y]=h                    ################################ tie breaking rule ##########################                                #minimum total cost f            minimum = min(cost.values())            keys = [k for k, v in cost.items() if v==minimum]            #if only one            if len(keys)==1:                #update pointer to that position, move to that position                pointer = keys[0]            #if more than one position has same minimun total value            else:                #dictionary of positions with min total value and there h value                h_min = [(k,v) for k,v in h_fun.items() if k in keys]                h_min = dict(h_min)                #total positions with min f and h value                h_val = [k for k,v in h_min.items() if v == min(h_min.values())]                #if one position has min f and h value                if len(h_val)==1:                    #update pointer                    pointer = h_val[0]                #else if one position has min f and g value                elif len(g_val)==1:                    #update pointer                    pointer = g_val[0]                #all values are same for these positions till now, so we will choose the most right or down position                else:                    #list of positions row and column as x and y                    x = [k[0] for k in keys]                    y = [k[1] for k in keys]                    #if only one position is at most down row                    if x.count(max(x)) == 1:                        #update pointer to move down                        pointer = [x for x in keys if x[0]==max(x)]                    else:                        #else update pointer to move to most right column                        pointer = [x for x in keys if x[1]==max(y)]                                    #update node identtifier and open list for next node (new Pointer)                        S[pointer] = S[start]+'-'+action(start,pointer)            O[pointer] = O[start]+'-'+action(start,pointer)            #update all new open nodes to open list            for n in pos_moves:                op.append(n)            op = list(set(op))                        #remove for open list if in close list            op = [n for n in op if n not in visited]                        #for each node in open list print node identifier,g,h,f            for n in op:                OPEN = OPEN +'('+N[n]+O[n]+' '+str(G[n])+' '+str(H[n])+' '+str(F[n])+')'+','            print(OPEN[:-1]+'}')            #for each node in closed list print node identifier,g,h,f            for n in visited:                closed = closed + '('+N[n]+S[n]+' '+str(G[n])+' '+str(H[n])+' '+str(F[n])+')'+','            print(closed[:-1]+'}')            # update new pointer (current position) to closed list            visited.append(pointer)            #update g till now            path = g_fun[pointer]            #update hueristic fun value for cuurent node            hur= h_fun[pointer]            #update current position            a= pointer[0]            b= pointer[1]                        #if goal is reached, finish!            if a==g1 and b==g2:                break        return outputdef read_from_file(file_name):    # You can change the file reading function to suit the way    # you want to parse the file    file_handle = open(file_name)    map = file_handle.read().strip().split("\n")    return map########################################################################################## DO NOT CHANGE ANYTHING BELOW #####################################################################################################################def write_to_file(file_name, solution):    file_handle = open(file_name, 'w')    file_handle.write(solution)def main():    # create a parser object    parser = ap.ArgumentParser()    # specify what arguments will be coming from the terminal/commandline    parser.add_argument("input_file_name", help="specifies the name of the input file", type=str)    parser.add_argument("output_file_name", help="specifies the name of the output file", type=str)    parser.add_argument("flag", help="specifies the number of steps that should be printed", type=int)    # parser.add_argument("procedure_name", help="specifies the type of algorithm to be applied, can be D, A", type=str)    # get all the arguments    arguments = parser.parse_args()############################################################################### these print statements are here to check if the arguments are correct.#    print("The input_file_name is " + arguments.input_file_name)#    print("The output_file_name is " + arguments.output_file_name)#    print("The flag is " + str(arguments.flag))#    print("The procedure_name is " + arguments.procedure_name)##############################################################################    # Extract the required arguments    operating_system = platform.system()    if operating_system == "Windows":        input_file_name = arguments.input_file_name        input_tokens = input_file_name.split("\\")        if not re.match(r"(INPUT\\input)(\d)(.txt)", input_file_name):            print("Error: input path should be of the format INPUT\input#.txt")            return -1        output_file_name = arguments.output_file_name        output_tokens = output_file_name.split("\\")        if not re.match(r"(OUTPUT\\output)(\d)(.txt)", output_file_name):            print("Error: output path should be of the format OUTPUT\output#.txt")            return -1    else:        input_file_name = arguments.input_file_name        input_tokens = input_file_name.split("/")        if not re.match(r"(INPUT/input)(\d)(.txt)", input_file_name):            print("Error: input path should be of the format INPUT/input#.txt")            return -1        output_file_name = arguments.output_file_name        output_tokens = output_file_name.split("/")        if not re.match(r"(OUTPUT/output)(\d)(.txt)", output_file_name):            print("Error: output path should be of the format OUTPUT/output#.txt")            return -1    flag = arguments.flag    # procedure_name = arguments.procedure_name    try:        map = read_from_file(input_file_name) # get the map    except FileNotFoundError:        print("input file is not present")        return -1    # print(map)        solution_string = "" # contains solution    solution_string = graphsearch(map, flag)    write_flag = 1        # call function write to file only in case we have a solution    if write_flag == 1:        write_to_file(output_file_name, solution_string)if __name__ == "__main__":    main()